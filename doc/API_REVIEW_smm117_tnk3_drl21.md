#Part 1

1. The View establishes a tree of Nodes that all generate Requests and pass them to their parent. Thus, new Nodes that influence data can easily be added to the UI, because their requests will all filter back to the View and be sent to the Controller from the same class. Updates also all occur in one class, so if a Node needs to be updated when data is changed, you simply need to call its updating method in the View's *update()* method. Are View is also able to display any kind of game, as long as it is held in a grid and is not real time, leaving the options of game genres wide open.
2. Because the View just sends requests to the Controller and obtains any resulting changes from the GameState, it doesn't need to know how those requests are actually carried out. Thus, all game logic is encapsulated.
3. My part (the View) is observing the Model, updating the GUI whenever changes occur. It also sends Requests to the Controller whenever they are generated by user interaction with the GUI.
4. The main error that can occur in the GUI is invalid input. This can come in the form of the user making an illegal move or providing invalid data when making a new Sprite. For invalid moves, the resulting Request will still be sent to the Controller. Errors will then be detected by the engine. If an error occurs here, then nothing is changed in the Model and the View returns to the previous state. If the user gives invalid data, then this should be handled by the class that is given this data, and a Request should never make it to the View.
5. Additions can easily be made to the front end without having any knowledge of how the back end operates.

#Part 2

1. I am excited to try to add default templates to the StartUp Wizard. This would allow the user to, instead of starting from scratch, work in an environment that already has Sprites available to build with.

2. I am most worried about working on communication between the different portions of the project (Model, View, Controller).